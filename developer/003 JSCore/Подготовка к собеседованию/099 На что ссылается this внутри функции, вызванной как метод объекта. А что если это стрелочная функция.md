#### Ответ

*Внутри функции*, вызванной как метод объекта, значение `this` ссылается на сам объект, который вызывает метод. То есть `this` указывает на контекст объекта, который является контейнером для вызываемого метода.

```
const obj = {
  name: "John",
  greet: function() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

obj.greet(); // "Hello, my name is John"
```

В этом примере `this` внутри метода `greet()` ссылается на объект `obj`, потому что метод вызывается как метод этого объекта.

Если бы та же функция была определена как *стрелочная функция*, то значение `this` было бы *унаследовано из контекста внешней функции*, где была определена стрелочная функция.

```
const obj = {
  name: "John",
  greet: () => {
    console.log(`Hello, my name is ${this.name}`);
  }
};

obj.greet(); // "Hello, my name is undefined"
```

В этом примере `this` внутри стрелочной функции `greet()` ссылается на контекст, в котором она была определена — глобальный объект в браузере или объект `global` в Node.js. Поэтому значение `this.name` будет `undefined`, потому что свойство `name` не определено в глобальном объекте.

Важно понимать, что использование стрелочных функций в качестве методов объектов может приводить к ошибкам и неожиданным результатам в работе кода, так как `this` внутри стрелочных функций не указывает на объект, который вызывает метод. Поэтому рекомендуется использовать обычные функции в качестве методов объектов, особенно если они используют значение `this`.

___
 #JS #this

___

### [[003 JSCore|Назад]]