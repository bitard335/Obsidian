____

tags: #testing #unit-test #unit-fake

[[9. Тестирование|Назад]]

![Что такое Fake в unit тестировании?](https://youtu.be/i96lHslBOIc?t=126)

#### keywords:

##### Теория

В unit-тестировании Fake (англ. "фейк") - это объект, который имитирует поведение реального объекта, но не является точной его копией, а создается специально для тестирования. Fake обычно используется, когда необходимо создать объект, который зависит от других компонентов, которые еще не готовы или не доступны на момент тестирования.

Fake может имитировать различные объекты, такие как базы данных, файловые системы, сетевые соединения, а также другие объекты, которые сложно воссоздать в тестовой среде или которые могут повлиять на результаты тестирования. 

Fake может быть реализован в виде заглушки (англ. #unit-mock ), подмены (англ. #unit-stub) или имитации (англ. #unit-dummy ).

Использование Fake в unit-тестировании позволяет изолировать тестируемый объект от внешних зависимостей и контролировать его поведение в тестовых условиях. Это позволяет улучшить качество и надежность программного обеспечения, а также ускорить процесс тестирования.

##### Пример

Представим, что у нас есть класс `UserService`, который зависит от базы данных для получения информации о пользователях. Класс `UserService` имеет метод `getUserNameById`, который принимает на вход идентификатор пользователя и возвращает его имя. Для тестирования этого метода нам нужно имитировать работу базы данных, чтобы изолировать тестируемый объект от внешних зависимостей.

Мы можем создать Fake объект `UserRepository`, который будет имитировать работу базы данных. Для этого нам нужно создать класс `FakeUserRepository`, который будет иметь те же методы, что и реальный объект `UserRepository`, но будет возвращать фиктивные данные.

```
class FakeUserRepository {
  getUsers() {
    return [{ id: 1, name: "John" }, { id: 2, name: "Jane" }];
  }

  getUserById(id) {
    const users = this.getUsers();
    return users.find(user => user.id === id);
  }
}
```

Затем мы можем создать объект `UserService` и передать ему в качестве зависимости Fake объект `FakeUserRepository`.

```
const userService = new UserService(new FakeUserRepository());
```

Теперь мы можем вызвать метод `getUserNameById` на объекте `userService` и убедиться, что он возвращает правильное имя пользователя, используя данные из Fake объекта `FakeUserRepository`.

```
const userName = userService.getUserNameById(1);
assert.equal(userName, "John");
```

Таким образом, использование Fake объекта позволяет нам изолировать тестируемый объект от внешних зависимостей и контролировать его поведение в тестовых условиях.
_____
