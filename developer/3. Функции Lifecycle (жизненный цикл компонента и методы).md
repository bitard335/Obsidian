#### 3. Функции #Lifecycle (жизненный цикл компонента и методы)

###### Зачем нужен жизненный цикл?

Жизненный цикл используется в те моменты, когда компонентам нужно выполнить код ( в какие - то определенные моменты своей жизни ) , например, перед тем, как компонент будет удалён, необходимо очистить ресурсы.

##### Методы жизненного цикла

Сначала в компоненте создаются через constructor состояния и свойства, затем React вызывает функцию render. Render возвращает дерево React-элементов, а эти элементы превращаются в DOM-элементы, которые затем добавляются в DOM-дерево на странице. Затем компонент может некоторое время обновляться.

В то время, когда компонент обновляется может произойти следующее событие:

Компонент может получить новое свойство, придётся вызвать функцию render , чтобы получить новое представление об элементах.

##### Функции жизненного цикла компонентов #lifecycle-hooks

#componentDidMount - #React исполнит этот код, когда он отобразится на странице в первый раз.

Этапы Lifecycle:
___1 #Mointing - компонент создаётся и впервые отображается на странице 
constructor() => render() => #componentDidMount()

___2 #Updates - компонент получает обновления
New Props
					=> render() => #componentDidUpdate()
setState()

___3 #Unmounting - компонент не нужен и он удаляется

#compomemtWillInmount

___4 #error - компонент выходит с ошибккой, которая не была поймана
 #componentDidCatch ()

Подробнее: [Методы жизненного цикла](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

###### #componentDidMount ()
Когда этот элемент вызван - это значит , что DOM-элемент гарантировано находится на странице и они проинициализированы.

Он используется для иницициализации (запросы к API, асинхронное получение данных и тд)
%%Не используйте конструктор, для кода, который создаёт побочные эффекты.%%

Вы **можете сразу вызвать setState()** в `componentDidMount()`. Это вызовет дополнительный рендер перед тем, как браузер обновит экран. Гарантируется, что пользователь не увидит промежуточное состояние, даже если `render()` будет вызываться дважды. Используйте этот подход с осторожностью, он может вызвать проблемы с производительностью. В большинстве случаев начальное состояние лучше объявить в `constructor()`. Однако, это может быть необходимо для случаев, когда нужно измерить размер или положение DOM-узла, на основе которого происходит рендер. Например, для модальных окон или всплывающих подсказок.

###### #componentDidUpdate()

```
componentDidUpdate(prevProps, prevState, snapshot)
```

Он вызывается после того, как компонент обновился. А компонент обновляется после того, как получает новые свойства или #State 
Этот метод вызывается после render - в нём можно, к примеру, запрашивать новые данные для обновленных свойств.

```
componentDidUpdate(prevProps) {
  // Популярный пример (не забудьте сравнить пропсы):
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
```

В `componentDidUpdate()` **можно вызывать `setState()`**, однако его **необходимо обернуть в условие**, как в примере выше, чтобы не возник бесконечный цикл. Вызов `setState()` влечет за собой дополнительный рендер, который незаметен для пользователя, но может повлиять на производительность компонента. Вместо «отражения» пропсов в состоянии рекомендуется использовать пропсы напрямую. 

Подробнее о том, [почему копирование пропсов в состояние вызывает баги](https://ru.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html).

В тех редких случаях когда реализован метод жизненного цикла `getSnapshotBeforeUpdate()`, его результат передаётся `componentDidUpdate()` в качестве третьего параметра `snapshot`.

> Примечание:
> `componentDidUpdate()` не вызывается (после рендера) , если [`shouldComponentUpdate()`](https://ru.reactjs.org/docs/react-component.html#shouldcomponentupdate) возвращает `false`.

###### #compomemtWillInmount ()
С помощью этого метода вызывается удаление компонента.
Метод используется для очистки ресурсов (таймеры, интервалы, запросы к серверу и др)

В момент вызова метода DOM все еще находится на странице.

**Не используйте setState()** в `componentWillUnmount()`, так как компонент никогда не рендерится повторно. После того, как экземпляр компонента будет размонтирован, он никогда не будет примонтирован снова.

###### #componentDidCatch ()
```
componentDidCatch(error, info)
```
1.  `error` — перехваченная ошибка
2.  `info` — объект с ключом `componentStack`, содержащий [информацию о компоненте, в котором произошла ошибка](https://ru.reactjs.org/docs/error-boundaries.html#component-stack-traces).

Задача этого метода отлов ошибок из функций, которые отвечают за корректный рендер компонентов. Принцип работы метода схож с try/catch , т.е ошибку отлавливает каждый блок.

Не обрабатываются ошибки в event listener ' ах и в асинхронном коде (запросы к серверу и т.п.)

```
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // Обновите состояние так, чтобы следующий рендер показал запасной интерфейс.
    return { hasError: true };
  }

  componentDidCatch(error, info) {    // Пример "componentStack":    //   in ComponentThatThrows (created by App)    //   in ErrorBoundary (created by App)    //   in div (created by App)    //   in App    logComponentStackToMyService(info.componentStack);  }
  render() {
    if (this.state.hasError) {
      // Здесь можно рендерить запасной интерфейс
      return <h1>Что-то пошло не так.</h1>;
    }

    return this.props.children;
  }
}
```

Обработка ошибок в методе `componentDidCatch()` отличается между React-сборками для продакшена и разработки.

В процессе разработки ошибки будут подниматься (всплывать) наверх до объекта `window`, поэтому любой вызов `window.onerror` или `window.addEventListener('error', callback)` перехватит ошибки, которые были обработаны `componentDidCatch()`.

На продакшене, напротив, ошибки не всплывают, поэтому родительский обработчик ошибок перехватит только те ошибки, которые не были обработаны `componentDidCatch()`.

> Примечание:
> 
> В случае ошибки вы можете рендерить запасной интерфейс с помощью `componentDidCatch()`, вызвав `setState`. Однако, этот способ скоро будет считаться устаревшим. Используйте `static getDerivedStateFromError()` для рендера резервного интерфейса.
